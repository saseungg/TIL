# 딥다이브 3장, 4장을 읽고 정리
딥다이브를 보고 생각나는 내용을 끄적임. 틀린 부분이 있을 수 있음 

## 브라우저와 nodeJS
자바스크립트는 브라우저와 node js에서만 실행 시킬 수 있는 언어이다. 브라우저와 nodejs는 목적이 다른데 브라우저는 html,css,js를 브라우저에 렌더링 하는 것이고 nodejs는 자바스크립트를 실행시키는 환경을 만드는 것이다. 둘의 목적과 용도가 다르고 둘은 ECMASciprt만 사용할 수 있다는 점은 같지만 브라우저에서만 사용할 수 있는 브라우저 api 노드 js에서만 사용할 수 있는 nodejs만 사용이 가능하며, 즉 ECMAscript 이외에는 서로 호환이 가능하지 않다.

## 연산과 메모리 할당
10 + 20이라는 코드를 입력했을 때 컴퓨터는 10, 20이라는 숫자를 메모리에 할당을 하고 연산은 cpu가 수행을 한다. 연산을 해서 나온 숫자 30은 새로운 메모리에 추가적으로 할당이 된다. 이전에 이야기했듯이 컴퓨터는 1,0 2진법으로 이루어져 있기 때문에 메모리의 주소와 메모리의 주소값은 전부 2진법으로 이루어져 있다. 메모리 한 셀의 크기는 1바이트 (8비트)로 구성되어있다. 

## 변수
변수는 메모리 주소를 참조하는 값이다. 자바스크립트는 개발자의 메모리 주소 제어를 허용하지 않는다. 메모리 공간은 코드가 실행될 때 새롭게 메모리 상황에 따라 임의로 결정되므로 이전에 실행했던 주소와 지금 주소공간이 동일하다고 볼 수 가 없다. 따라서 사용자가 직접적으로 메모리 주소공간에 접근해서 값을 변경하는 것은 올바르지 않다. 그래서 우리는 변수를 통해 해당 값을 변경하고 싶다고 요청하면 자바스크립트 엔진이 메모리주소공간으로 이동시켜줘서 값에 접근할 수 있도록 해준다고 보면된다.

## 선언과 초기화
```js
[1]
let a;
a=20;
[2]
let a =20;
```
둘은 다르게 보이지만 1번과 2번의 내부 동작과정은 똑같다.
자바스크립트는 let a 즉 선언이 되면 메모리 공간에 변수를 할당해서 식별자를 붙인다. 그러면 그 변수에 공간은 그대로 두는가? 아니다. 초기화 과정을 거쳐야한다. 그 이유는 이전에 메모리공간에 들어있던 값이 있을 수도 있기 때문에 초기화 과정을 통해 이전의 값을 날려준다고 보면된다. 초기화는 자동으로 undefined가 붙는다. 그래서 이과정을 수행하고 나서 20으로 새로운 메모리공간에 20을 할당하고 그 주소값을 참조해서 변수가 들어간다고 보면된다.

## 호이스팅
```
console.log(a)
var a;
```
호이스팅은 값이 먼저 선언된 것처럼 보이는것을 말하는데 자바스크립트는 런타임으로 순차적으로 실행시키기 이전에 식별자들을 전부 선언하고 런타임으로 순차적으로 실행되므로 콘솔을 찍었을떄 undefined가 되는 것이다. var 뿐만 아니라 let, class, function, 객체, 배열 전부 그렇게 동작하는데 일부 안되는 것처럼 보이는 것이다.

## 가비지 컬렉터
가비지 컬렉터가 식별자가 없는 안쓰는 메모리 공간을 임의의 시점에 삭제해준다. 근데 그시점은 정확히 알 수가 없다.

## 실행 컨텍스트
변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다. 변수 이름과 변수 값은 실행 컨텍스트 내에 키 값 형식인 객체로 등록되어 관리된다.



